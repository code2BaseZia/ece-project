; Tests.asm

; Operations Definitions (outdated):
; SW0: Set argument A (1)
; SW1: Set argument B (2)
; SW2: Set current operation (4)
; SW3: Return to outputs (8)
; SW8: Clear arguments and outputs (256)
; DURING OUTPUT PHASE: SW0 toggles between OUT_A and OUT_B

; LED Definitions (outdated):
; LED 0: Setting argument A
; LED 1: Setting argument B
; LED 2: Setting current operation
; LED 3: Displaying output A
; LED 4: Displaying output B
; LED 0 & 9: Setting mode
; LEDs 4-0 Snaking: Working
; LEDs 9-0 Blinking: ERROR

; CURR_OP Definitions
; SW0: ADD (1)
; SW1: SUB (2)
; SW2: MULT (4)
; SW2&0: MULT_UNSIGNED (5)
; SW3: DIV (8)
; SW3&0: DIV_UNSIGNED (9)
; SW4: SQRT (16)
; SW5: SIN/COS (32)

; CTRL / STATUS bits
; bit 0: START (write 1 to begin)
; bit 1: OP_DIV (1 = DIV, 0 = MUL unless SQRT/CORDIC selected)
; bit 2: SIGNED (1=signed, 0=unsigned) for MUL/DIV
; bit 3: OP_SQRT (1=SQRT)
; bit 4: OP_CORDIC (1=CORDIC)
; Status bits 5-7
; ST_DONE : 0
; ST_BUSY : 1
; ST_DIV0 : 2 (set for divide-by-zero)



ORG 0
CLEAR:  ; Reset/set values on startup/clear
	LOADI 0
	STORE ARG_A
	STORE ARG_B
    STORE OUT_A
	STORE OUT_B
    STORE CURR_OP
    STORE CURR_LED_VALUE
    STORE CURR_OUT
    STORE CURR_MODE
    STORE CURR_CTRL
    STORE SWITCHES_IN
    CALL DISPLAY_LEDS
    CALL DISPLAY_OP
    CALL DISPLAY_OUT
    
GOTO_TEST: ; Switches go to specific test
	IN SWITCHES
    STORE SWITCHES_IN
    ADDI -1
    JZERO MULT_TEST
    LOAD SWITCHES_IN
    ADDI -2
    JZERO MULT_UNSIGNED
    LOAD SWITCHES_IN
    ADDI -4
    JZERO MULT_SIGNED
    LOAD SWITCHES_IN
    ADDI -8
    JZERO DIV_TEST
    LOAD SWITCHES_IN
    ADDI -16
    JZERO DIV_UNSIGNED
    LOAD SWITCHES_IN
    ADDI -32
    JZERO DIV_SIGNED
    LOAD SWITCHES_IN
    ADDI -64
    JZERO SQRT_TEST
    LOAD SWITCHES_IN
    ADDI -128
    JZERO CORDIC_TEST
    LOAD SWITCHES_IN
    ADDI -256
    JZERO DIV0_TEST
    JUMP GOTO_TEST
    
MULT_TEST:
	LOADI 1
    STORE CURR_LED_VALUE
    CALL DISPLAY_LEDS
    CALL DELAY
MULT_UNSIGNED:
	LOADI 2
    STORE CURR_LED_VALUE
    CALL DISPLAY_LEDS
    LOADI 5
    STORE CURR_OP
    ; SET UNSIGNED ARGS
    LOADI 5
    STORE ARG_A
    LOADI 2
    STORE ARG_B
    
    CALL OP_MULT
    CALL DO_OUTPUTS
MULT_SIGNED:
	LOADI 3
    STORE CURR_LED_VALUE
    LOADI 4
    STORE CURR_OP
    CALL DISPLAY_LEDS
    ; SET SIGNED ARGS
    LOADI 2
    STORE ARG_A
    LOADI -10
    STORE ARG_B
    
    CALL OP_MULT
    CALL DO_OUTPUTS
DIV_TEST:
	LOADI 4
    STORE CURR_LED_VALUE
    CALL DISPLAY_LEDS
DIV_UNSIGNED:
	LOADI 5
    STORE CURR_LED_VALUE
    LOADI 9
    STORE CURR_OP
    CALL DISPLAY_LEDS
    ; SET UNSIGNED ARGS
    LOADI 10
    STORE ARG_A
    LOADI 3
    STORE ARG_B
    
    CALL OP_DIV
    CALL DO_OUTPUTS
DIV_SIGNED:
	LOADI 5
    STORE CURR_LED_VALUE
    LOADI 8
    STORE CURR_OP
    CALL DISPLAY_LEDS
    ; SET SIGNED ARGS
    LOADI 15
    STORE ARG_A
    LOADI -3
    STORE ARG_B
    
    CALL OP_DIV
    CALL DO_OUTPUTS
SQRT_TEST:
	LOADI 6
    STORE CURR_LED_VALUE
    LOADI 16
    STORE CURR_OP
    CALL DISPLAY_LEDS
    ; SET ARGS
    LOADI 16
    STORE ARG_A
    
    CALL OP_SQRT
    CALL DO_OUTPUTS
    
    LOADI 16
    STORE CURR_OP
    LOADI 15
    STORE ARG_A
    
    CALL OP_SQRT
    CALL DO_OUTPUTS
CORDIC_TEST:
	LOADI 7
    STORE CURR_LED_VALUE
    LOADI 32
    STORE CURR_OP
    CALL DISPLAY_LEDS
    ; SET ARGS
    LOADI 90
    STORE ARG_A
    
    CALL OP_CORDIC
    CALL DO_OUTPUTS
	
DIV0_TEST:
	LOADI 8
    STORE CURR_LED_VALUE
    LOADI 8
    STORE CURR_OP
    CALL DISPLAY_LEDS
    ; SET SIGNED ARGS
    LOADI 15
    STORE ARG_A
    LOADI 0
    STORE ARG_B
    
    CALL OP_DIV
    
    CALL DONE

DIV0:
	LOADI 15
    STORE CURR_LED_VALUE
    CALL DISPLAY_LEDS
    JUMP DIV0

ERROR:
	LOAD LED_ERROR
    STORE CURR_LED_VALUE
	CALL DISPLAY_LEDS
	LOAD CURR_CTRL
    STORE CURR_OP
	CALL DISPLAY_OP
ERROR_LOOP:
	LOAD OUT_A
    STORE CURR_OUT
    CALL DISPLAY_OUT
	IN SWITCHES
    ADDI -1
    JZERO D_OUT_B
    JUMP ERROR_LOOP
    
D_OUT_B:
	LOAD OUT_B
    STORE CURR_OUT
    CALL DISPLAY_OUT
	IN SWITCHES
    JZERO ERROR_LOOP
    JUMP D_OUT_B
    
DO_OUTPUTS:
	CALL DISPLAY_OUT
    CALL DELAY_OU
    LOAD OUT_B
    STORE CURR_OUT
    CALL DISPLAY_OUT
    CALL DELAY_OU
    RETURN
    
DONE:
	JUMP DONE
    
READ_STATUS: ; Read the status from the status register into AC
	IN CTRL/STATUS
    AND STATUS_MASK
    RETURN


SET_CTRL:	
	LOAD CURR_CTRL
	RETURN
    
CHECK_DONE:
	CALL READ_STATUS
    JZERO EXIT_WORKING_LOOP
    RETURN
    
DELAY_OU:
	OUT Timer
DELAY_OUL:
	IN Timer
    ADDI -100
    JNEG DELAY_OUL
DELAY_OUE:
	RETURN
    
    
DELAY:
	OUT Timer
DELAY_L:
	IN Timer
    ADDI -10
    JNEG DELAY_L
DELAY_E:
	RETURN
	
DISPLAY_LEDS:
	LOAD CURR_LED_VALUE
    OUT LEDs
    RETURN
    
DISPLAY_OP:
	LOAD CURR_OP
	OUT Hex1
    RETURN
    
DISPLAY_OUT:
	LOAD CURR_OUT
    OUT Hex0
    RETURN

LED_WORKING_LOOP:
	CALL CHECK_DONE
	LOADI 16
    STORE CURR_LED_VALUE
    CALL DISPLAY_LEDS
    CALL DELAY
    CALL CHECK_DONE
    LOADI 8
    STORE CURR_LED_VALUE
    CALL DISPLAY_LEDS
    CALL DELAY
    CALL CHECK_DONE
    LOADI 4
    STORE CURR_LED_VALUE
    CALL DISPLAY_LEDS
    CALL DELAY
    CALL CHECK_DONE
    LOADI 2
    STORE CURR_LED_VALUE
    CALL DISPLAY_LEDS
    CALL DELAY
    CALL CHECK_DONE
    LOADI 1
    STORE CURR_LED_VALUE
    CALL DISPLAY_LEDS
    CALL DELAY
    CALL CHECK_DONE
    JUMP LED_WORKING_LOOP

EXIT_WORKING_LOOP:
	LOAD CURR_OP
    ADDI -4
    JZERO RES_MULT
    LOAD CURR_OP
    ADDI -5
    JZERO RES_MULT
    LOAD CURR_OP
    ADDI -8
    JZERO RES_DIV
    LOAD CURR_OP
    ADDI -9
    JZERO RES_DIV
    LOAD CURR_OP
    ADDI -16
    JZERO RES_SQRT
    LOAD CURR_OP
    ADDI -32
    JZERO RES_CORDIC
    JUMP MODE_ERROR ; If somehow invalid op happens then give up and explode

RES_MULT:
	; check for overflow
    IN LO
    STORE OUT_A
    IN HI
    STORE OUT_B
    RETURN
    
RES_DIV:
	CALL READ_STATUS
    ADDI -2
    JZERO DIV0 ; If ST_DIV0 is raised go to error 
    IN QUO
    STORE OUT_A
    IN REM
    STORE OUT_B
    RETURN

RES_SQRT:
	IN SQR_OU
    STORE OUT_A
    RETURN

RES_CORDIC:
	IN SIN
    STORE OUT_A
    IN COS
    STORE OUT_B
    RETURN

LOAD_ARGS:
	LOAD ARG_A
    OUT ARG_AIO
    LOAD ARG_B
    OUT ARG_BIO
    RETURN

OP_ADD:
	LOAD ARG_A
    ADD ARG_B
    STORE OUT_A
	RETURN
    
OP_SUB:
	LOAD ARG_A
    SUB ARG_B
    STORE OUT_A
	RETURN
    
OP_MULT: 
	CALL LOAD_ARGS
    LOAD CURR_OP
    ADDI -4
    JZERO OP_MULTS ; Jump to perform signed multiplication
    LOADI 1
    STORE CURR_CTRL
    CALL SET_CTRL ; This will start the peripheral
	JUMP OP_MULT_C
OP_MULTS:
	LOADI 5
    STORE CURR_CTRL
    CALL SET_CTRL ; This will start the peripheral for signed mult
OP_MULT_C:
    JUMP LED_WORKING_LOOP
    
OP_DIV: 
	CALL LOAD_ARGS
    LOAD CURR_OP
    ADDI -9
    JZERO OP_DIVS
    LOADI 3
    STORE CURR_CTRL
    CALL SET_CTRL ; This will start the peripheral
    JUMP OP_DIV_C
OP_DIVS:
	LOADI 7
    STORE CURR_CTRL
    CALL SET_CTRL ; This will start the peripheral
OP_DIV_C:
	JUMP LED_WORKING_LOOP
    
OP_SQRT:
	LOAD ARG_A
    OUT ARG_AIO
    LOADI 8
    STORE CURR_CTRL
    CALL SET_CTRL ; This will start the peripheral
    JUMP LED_WORKING_LOOP
    
OP_CORDIC:
	LOAD ARG_A
    OUT ARG_AIO
	LOADI 16
    STORE CURR_CTRL
    CALL SET_CTRL ; This will start the peripheral
	JUMP LED_WORKING_LOOP
    
MODE_ERROR:
	LOAD LED_ERROR
    STORE CURR_LED_VALUE
    CALL DISPLAY_LEDS
    CALL DELAY
    LOADI 0
    STORE CURR_LED_VALUE
    CALL DISPLAY_LEDS
    CALL DELAY
    JUMP MODE_ERROR
    
; Memory constants/masks
SWITCHES_IN: DW 0
ARG_A: DW 0
ARG_B: DW 0
OUT_A: DW 0
OUT_B: DW 0
CURR_OP: DW 0
CURR_OP_MASK: DW &H01FF
BIT0_MASK: DW &H0001
STATUS_MASK: DW &H00E0
CURR_CTRL: DW 0
CURR_OUT: DW 0
CURR_MODE: DW 0

; LED Constants
CURR_LED_VALUE: DW 0
LED_SETA: EQU 001
LED_SETB: EQU 002
LED_OUTA: EQU 008
LED_OUTB: EQU 016
LED_SETM: EQU 513
LED_SETOP: EQU 004
LED_ERROR: DW &H03FF

; IO address constants
Switches:  EQU 000
LEDs:      EQU 001
Timer:     EQU 002
Hex0:      EQU 004
Hex1:      EQU 005

CTRL/STATUS: EQU &H90
ARG_AIO:     EQU &H92
ARG_BIO:     EQU &H93
LO:        EQU &H94
HI:        EQU &H95
QUO:       EQU &H96
REM:       EQU &H97
SQR_OU:    EQU &H98
SIN:        EQU &H99
COS:        EQU &H9A